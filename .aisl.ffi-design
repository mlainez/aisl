# AISL FFI Design Specification
# Last Updated: 2026-02-07
# Status: Design Phase

## Core Principle
**Simple, explicit, Lua-like FFI optimized for LLM code generation**

## Design Goals
1. Minimal API surface (3-4 core operations)
2. Explicit type marshalling (no magic conversions)
3. Predictable for LLMs (one way to do things)
4. Automatic fallback to pure AISL
5. No runtime reflection/introspection (compile-time only)

## FFI Operations

### 1. Load Native Library
```lisp
(set lib handle (call ffi_load "libaisl_http"))
; Returns: handle to loaded library, or null on failure
; Auto-searches: ./extensions/*.so, ~/.aisl/extensions/*.so, /usr/lib/aisl/extensions/*.so
```

### 2. Call C Function (Direct)
```lisp
(set result string (call ffi_call lib "http_get" "https://example.com"))
; Type marshalling is automatic based on AISL types
; Returns: AISL value (int, float, string, bool, or handle)
```

### 3. Check Library Availability
```lisp
(set available bool (call ffi_available "libaisl_http"))
; Returns: true if library can be loaded, false otherwise
; Used for fallback logic
```

### 4. Close Library (Optional - for cleanup)
```lisp
(call ffi_close lib)
; Unloads library, invalidates handle
; Usually not needed - VM auto-closes on exit
```

## Type Marshalling Rules

### AISL → C (Arguments)
```
int    → int64_t
float  → double
string → const char* (UTF-8, null-terminated)
bool   → int (0=false, 1=true)
handle → void* (opaque pointer)
```

### C → AISL (Return Values)
```
int64_t      → int
double       → float
const char*  → string (copied, caller frees original)
int (0/1)    → bool
void*        → handle (opaque, tracked by GC)
void         → int (returns 0)
```

### Handle Type
- Opaque pointer to C data structures
- Tracked by AISL GC (with optional C destructor)
- Cannot be inspected from AISL
- Only passed back to C functions

## C Function Signature Convention

All FFI-callable C functions must follow this pattern:

```c
// Return value type + _aisl suffix
int64_t my_function_aisl(int64_t arg1, const char* arg2);
double  calculate_aisl(double x, double y);
char*   format_string_aisl(const char* template, int64_t value);
void*   create_object_aisl(const char* config);
void    destroy_object_aisl(void* obj);
```

**Rules:**
1. Functions must end with `_aisl` suffix (convention, not enforced)
2. Use standard C types (int64_t, double, const char*, void*)
3. Strings returned must be heap-allocated (AISL will free them)
4. Handles (void*) are automatically GC-tracked

## Extension Module Structure

```
extensions/
  http/
    http.c              # C implementation
    http.h              # C header
    Makefile            # Build libaisl_http.so
    http_pure.aisl      # Pure AISL fallback (optional)
  regex/
    regex.c
    regex.h
    Makefile
    regex_pure.aisl
```

## AISL Module Pattern (With Fallback)

```lisp
(module http
  ; Try to load native extension
  (set native_lib handle (call ffi_load "libaisl_http"))
  (set has_native bool (call ne native_lib 0))
  
  ; Public API function with automatic fallback
  (fn http_get url string -> string
    (set result string "")
    (if has_native
      ; Native path
      (set result string (call ffi_call native_lib "http_get_aisl" url))
      ; Pure AISL fallback
      (set result string (call http_get_pure url)))
    (ret result))
  
  ; Pure AISL implementation (always available)
  (fn http_get_pure url string -> string
    ; Implement HTTP GET in pure AISL
    ; Slower, but works everywhere
    (ret "pure AISL implementation")))
```

## VM Implementation Details

### Opcode: OP_FFI_LOAD
```
Stack before: [library_name_string]
Stack after:  [handle_int_or_0]
```

### Opcode: OP_FFI_CALL
```
Stack before: [handle, function_name, arg1, arg2, ..., argN, arg_count]
Stack after:  [return_value]
```

### Opcode: OP_FFI_AVAILABLE
```
Stack before: [library_name_string]
Stack after:  [bool]
```

### Opcode: OP_FFI_CLOSE
```
Stack before: [handle]
Stack after:  []
```

## C Extension API

### Initialization Function (Required)
```c
// Called when library is loaded
// Returns: 0 on success, non-zero on error
int aisl_extension_init(void) {
    // Initialize library resources
    return 0;
}
```

### Cleanup Function (Optional)
```c
// Called when library is unloaded
void aisl_extension_cleanup(void) {
    // Clean up library resources
}
```

### Function Registration (Automatic)
- Functions are looked up via dlsym() at call time
- No explicit registration needed
- Function must be exported (non-static)

## Build System Integration

### Makefile Pattern for Extensions
```makefile
# extensions/http/Makefile
CC = gcc
CFLAGS = -Wall -Wextra -fPIC -O2
LDFLAGS = -shared -lcurl -lssl -lcrypto

libaisl_http.so: http.c http.h
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ http.c

install:
	install -D libaisl_http.so $(DESTDIR)/usr/lib/aisl/extensions/libaisl_http.so

clean:
	rm -f libaisl_http.so
```

### Main Makefile Integration
```makefile
# Build extensions if dependencies available
extensions:
	@if pkg-config --exists libcurl; then \
		$(MAKE) -C extensions/http; \
	else \
		echo "Skipping HTTP extension (libcurl not found)"; \
	fi
	@if pkg-config --exists pcre2; then \
		$(MAKE) -C extensions/regex; \
	else \
		echo "Skipping regex extension (using system regex)"; \
	fi
```

## Error Handling

### Library Load Failures
```lisp
(set lib handle (call ffi_load "libaisl_missing"))
; lib = 0 (null handle)
; VM prints warning: "FFI: Failed to load libaisl_missing.so: <error>"
; Code checks: (if (call eq lib 0) ...)
```

### Function Call Failures
```lisp
(set result string (call ffi_call lib "missing_function" "arg"))
; VM crashes with: "FFI: Function 'missing_function' not found in library"
; This is intentional - invalid function = programming error
```

### Type Mismatches
```lisp
; C function expects (int64_t, const char*)
; AISL calls with (string, int) - WRONG ORDER
(call ffi_call lib "func" "hello" 42)
; Result: Undefined behavior (C doesn't know about type error)
; Solution: LLMs must match C signature exactly
```

**Design Choice: Crash on type mismatch rather than coerce**
- Makes errors obvious during development
- Forces LLMs to get types right
- No silent bugs from implicit conversions

## Security Considerations

1. **No arbitrary code execution**: Only loads signed/whitelisted libraries
2. **Sandboxing**: Extensions run in same process (no isolation yet)
3. **Memory safety**: C extensions can crash VM (accepted risk)
4. **Path traversal**: Library names are sanitized (no ../ allowed)

## Performance

- `ffi_load`: O(1) - cached after first load
- `ffi_call`: O(1) - direct function pointer call
- Type marshalling: O(n) for strings, O(1) for primitives
- Overhead: ~10-50ns per FFI call (vs pure AISL: ~5ns)

## LLM Code Generation Patterns

### Pattern 1: Conditional Native/Pure
```lisp
(module my_module
  (set lib handle (call ffi_load "libaisl_mymod"))
  (set has_lib bool (call ne lib 0))
  
  (fn my_func arg string -> string
    (if has_lib
      (ret (call ffi_call lib "my_func_aisl" arg))
      (ret (call my_func_pure arg))))
  
  (fn my_func_pure arg string -> string
    ; Pure AISL implementation
    (ret arg)))
```

### Pattern 2: Required Native (No Fallback)
```lisp
(module gpu_compute
  (set lib handle (call ffi_load "libaisl_gpu"))
  
  (fn init -> bool
    (if (call eq lib 0)
      (call print "ERROR: GPU extension required but not available")
      (ret false))
    (ret true))
  
  (fn compute data array -> array
    ; Crashes if lib not loaded - that's OK for required extensions
    (ret (call ffi_call lib "gpu_compute_aisl" data))))
```

### Pattern 3: Multi-Library
```lisp
(module my_module
  (set http_lib handle (call ffi_load "libaisl_http"))
  (set json_lib handle (call ffi_load "libaisl_json"))
  
  (fn fetch_and_parse url string -> json
    (set response string (call ffi_call http_lib "http_get_aisl" url))
    (set parsed json (call ffi_call json_lib "json_parse_aisl" response))
    (ret parsed)))
```

## Migration Strategy (VM Refactoring)

### Phase 1: Add FFI Subsystem (No Breaking Changes)
- Add OP_FFI_* opcodes
- Implement ffi_load, ffi_call, ffi_available
- Keep existing OP_HTTP_*, OP_REGEX_* opcodes working
- Test: FFI works alongside old opcodes

### Phase 2: Create Native Extensions (Parallel)
- Build extensions/http/libaisl_http.so (extract from VM)
- Build extensions/regex/libaisl_regex.so (extract from VM)
- Build extensions/websocket/libaisl_websocket.so (extract from VM)
- Test: Extensions work via FFI

### Phase 3: Create Pure AISL Fallbacks
- Write modules/*_pure.aisl for each extension
- Test: Pure AISL works without native libs

### Phase 4: Update Modules to Use FFI
- Modify modules/http.aisl to use FFI + fallback
- Modify modules/json_utils.aisl if needed
- Test: All 132 tests still pass

### Phase 5: Deprecate Old Opcodes
- Mark OP_HTTP_*, OP_REGEX_*, OP_WS_* as deprecated
- VM prints warning when used
- Update docs

### Phase 6: Remove Old Opcodes (Breaking Change)
- Delete VM implementations
- Delete deprecated opcodes
- Reduce VM size by ~400 lines
- Update version to 2.0.0

## Documentation for LLMs

Key points to communicate to LLMs:

1. **FFI is for C interop only** - not for AISL-to-AISL calls
2. **Always provide pure AISL fallback** - unless extension is required
3. **Match C signatures exactly** - no implicit conversions
4. **Check library availability** - use `ffi_available` or `ne lib 0`
5. **Handles are opaque** - don't inspect, just pass back to C

## Open Questions

1. **Variadic functions**: Support C varargs? (Probably NO - too complex)
2. **Struct passing**: Support C structs? (NO - use handles instead)
3. **Callback functions**: Can C call AISL functions? (Future: OP_FFI_CALLBACK)
4. **Array passing**: How to pass AISL arrays to C? (Convert to C array, pass pointer + length)
5. **Error codes**: Standard way for C to report errors? (Return -1 or null, set errno)

## Next Steps

1. Implement OP_FFI_LOAD, OP_FFI_CALL, OP_FFI_AVAILABLE in VM
2. Add FFI test suite
3. Extract HTTP to libaisl_http.so
4. Create http_pure.aisl fallback
5. Update modules/http.aisl to use FFI
6. Repeat for regex and websocket
7. Update documentation
