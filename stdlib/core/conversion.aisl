(module conversion
  (fn string_from_int n int -> string
    (set is_negative bool (call lt n 0))
    (set abs_n int n)
    (if is_negative
      (set abs_n int (call sub 0 n)))
    
    (set is_zero bool (call eq abs_n 0))
    (if is_zero
      (ret "0"))
    
    (set digits array (call array_new 32))
    (set remaining int abs_n)
    
    (while (call gt remaining 0)
      (set digit int (call mod remaining 10))
      (set remaining int (call div remaining 10))
      
      (set digit_char string "0")
      (if (call eq digit 1) (set digit_char string "1"))
      (if (call eq digit 2) (set digit_char string "2"))
      (if (call eq digit 3) (set digit_char string "3"))
      (if (call eq digit 4) (set digit_char string "4"))
      (if (call eq digit 5) (set digit_char string "5"))
      (if (call eq digit 6) (set digit_char string "6"))
      (if (call eq digit 7) (set digit_char string "7"))
      (if (call eq digit 8) (set digit_char string "8"))
      (if (call eq digit 9) (set digit_char string "9"))
      
      (call array_push digits digit_char))
    
    (set result string "")
    (set len int (call array_length digits))
    (set i int (call sub len 1))
    
    (while (call ge i 0)
      (set digit_str string (call array_get digits i))
      (set result string (call string_concat result digit_str))
      (set i int (call sub i 1)))
    
    (if is_negative
      (set result string (call string_concat "-" result)))
    
    (ret result))
  
  (fn string_from_float f float -> string
    (set is_negative bool (call lt f 0.0))
    (set abs_f float f)
    (if is_negative
      (set abs_f float (call sub 0.0 f)))
    
    (set int_part int (call cast_f64_i64 abs_f))
    (set int_str string (call string_from_int int_part))
    
    (set float_part float (call sub abs_f (call cast_i64_f64 int_part)))
    (set scaled float (call mul float_part 1000.0))
    (set frac_part int (call cast_f64_i64 scaled))
    
    (set result string int_str)
    (set result string (call string_concat result "."))
    
    (set frac_str string (call string_from_int frac_part))
    (set frac_len int (call string_length frac_str))
    
    (if (call lt frac_len 3)
      (if (call eq frac_len 1)
        (set frac_str string (call string_concat "00" frac_str)))
      (if (call eq frac_len 2)
        (set frac_str string (call string_concat "0" frac_str))))
    
    (set result string (call string_concat result frac_str))
    
    (if is_negative
      (set result string (call string_concat "-" result)))
    
    (ret result))
  
  (fn string_from_bool b bool -> string
    (if b
      (ret "true"))
    (ret "false"))
  
  (fn bool_to_int b bool -> int
    (if b
      (ret 1))
    (ret 0))
  
  (fn int_to_bool n int -> bool
    (set is_nonzero bool (call ne n 0))
    (ret is_nonzero))
  
  (fn kilometers_to_miles km float -> float
    (set miles_per_km float 0.621371)
    (set result float (call mul km miles_per_km))
    (ret result))
  
  (fn miles_to_kilometers miles float -> float
    (set km_per_mile float 1.60934)
    (set result float (call mul miles km_per_mile))
    (ret result))
  
  (fn celsius_to_fahrenheit c float -> float
    (set scaled float (call mul c 1.8))
    (set result float (call add scaled 32.0))
    (ret result))
  
  (fn fahrenheit_to_celsius f float -> float
    (set adjusted float (call sub f 32.0))
    (set result float (call div adjusted 1.8))
    (ret result))
  
  (meta-note "Conversion utilities: string_from_int, string_from_float, string_from_bool, bool_to_int, int_to_bool, distance/temperature conversions - pure AISL implementations"))