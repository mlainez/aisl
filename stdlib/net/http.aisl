(module http
  
  (fn string_from_int n int -> string
    (set is_negative bool (call lt n 0))
    (set abs_n int n)
    (if is_negative
      (set abs_n int (call sub 0 n)))
    
    (set is_zero bool (call eq abs_n 0))
    (if is_zero
      (ret "0"))
    
    (set digits array (call array_new 32))
    (set remaining int abs_n)
    
    (while (call gt remaining 0)
      (set digit int (call mod remaining 10))
      (set remaining int (call div remaining 10))
      
      (set digit_char string "0")
      (if (call eq digit 1) (set digit_char string "1"))
      (if (call eq digit 2) (set digit_char string "2"))
      (if (call eq digit 3) (set digit_char string "3"))
      (if (call eq digit 4) (set digit_char string "4"))
      (if (call eq digit 5) (set digit_char string "5"))
      (if (call eq digit 6) (set digit_char string "6"))
      (if (call eq digit 7) (set digit_char string "7"))
      (if (call eq digit 8) (set digit_char string "8"))
      (if (call eq digit 9) (set digit_char string "9"))
      
      (call array_push digits digit_char))
    
    (set result string "")
    (set len int (call array_length digits))
    (set i int (call sub len 1))
    
    (while (call ge i 0)
      (set digit_str string (call array_get digits i))
      (set result string (call string_concat result digit_str))
      (set i int (call sub i 1)))
    
    (if is_negative
      (set result string (call string_concat "-" result)))
    
    (ret result))
  
  (fn string_starts_with text string prefix string -> bool
    (set text_len int (call string_length text))
    (set prefix_len int (call string_length prefix))
    (if (call lt text_len prefix_len)
      (ret false))
    (set i int 0)
    (while (call lt i prefix_len)
      (set text_ch string (call string_slice text i (call add i 1)))
      (set prefix_ch string (call string_slice prefix i (call add i 1)))
      (set matches bool (call string_equals text_ch prefix_ch))
      (if (call not matches)
        (ret false))
      (set i int (call add i 1)))
    (ret true))
  
  (fn parse_url url string -> array
    (set arr array (call array_new 5))
    
    (set is_https bool (call string_starts_with url "https://"))
    (set is_http bool (call string_starts_with url "http://"))
    
    (if is_https
      (call array_push arr "https")
      (call array_push arr "http"))
    
    (set url_no_proto string url)
    (if is_https
      (set url_no_proto string (call string_slice url 8 (call string_length url))))
    (if is_http
      (set url_no_proto string (call string_slice url 7 (call string_length url))))
    
    (set slash_pos int -1)
    (set i int 0)
    (set url_len int (call string_length url_no_proto))
    (while (call lt i url_len)
      (set ch string (call string_slice url_no_proto i (call add i 1)))
      (set is_slash bool (call string_equals ch "/"))
      (if is_slash
        (set slash_pos int i)
        (break))
      (set i int (call add i 1)))
    
    (set host string url_no_proto)
    (set path string "/")
    (if (call ge slash_pos 0)
      (set host string (call string_slice url_no_proto 0 slash_pos))
      (set path string (call string_slice url_no_proto slash_pos url_len)))
    
    (call array_push arr host)
    
    (set port int 80)
    (if is_https
      (set port int 443))
    (call array_push arr port)
    
    (call array_push arr path)
    (ret arr))
  
  (fn build_request method string host string path string body string -> string
    (set req string method)
    (set req string (call string_concat req " "))
    (set req string (call string_concat req path))
    (set req string (call string_concat req " HTTP/1.1\r\n"))
    (set req string (call string_concat req "Host: "))
    (set req string (call string_concat req host))
    (set req string (call string_concat req "\r\n"))
    (set req string (call string_concat req "Connection: close\r\n"))
    
    (set body_len int (call string_length body))
    (if (call gt body_len 0)
      (set req string (call string_concat req "Content-Length: "))
      (set len_str string (call string_from_int body_len))
      (set req string (call string_concat req len_str))
      (set req string (call string_concat req "\r\n\r\n"))
      (set req string (call string_concat req body)))
    
    (set req string (call string_concat req "\r\n"))
    (ret req))
  
  (fn parse_response raw string -> map
    (set response map (call map_new))
    
    (set header_end int -1)
    (set i int 0)
    (set raw_len int (call string_length raw))
    (while (call lt i (call sub raw_len 3))
      (set substr string (call string_slice raw i (call add i 4)))
      (set is_crlf bool (call string_equals substr "\r\n\r\n"))
      (if is_crlf
        (set header_end int i)
        (break))
      (set i int (call add i 1)))
    
    (set body string "")
    (if (call ge header_end 0)
      (set body_start int (call add header_end 4))
      (set body string (call string_slice raw body_start raw_len)))
    
    (call map_set response "body" body)
    (call map_set response "status" 200)
    (ret response))
  
  (fn get url string -> map
    (set parts array (call parse_url url))
    (set protocol string (call array_get parts 0))
    (set host string (call array_get parts 1))
    (set port int (call array_get parts 2))
    (set path string (call array_get parts 3))
    
    (set sock string "")
    (set is_https bool (call string_equals protocol "https"))
    (if is_https
      (set sock string (call tcp_tls_connect host port))
      (set sock string (call tcp_connect host port)))
    
    (set req string (call build_request "GET" host path ""))
    (call tcp_send sock req)
    
    (set raw string (call tcp_receive sock 8192))
    (call tcp_close sock)
    
    (ret (call parse_response raw)))
  
  (fn post url string body string -> map
    (set parts array (call parse_url url))
    (set protocol string (call array_get parts 0))
    (set host string (call array_get parts 1))
    (set port int (call array_get parts 2))
    (set path string (call array_get parts 3))
    
    (set sock string "")
    (set is_https bool (call string_equals protocol "https"))
    (if is_https
      (set sock string (call tcp_tls_connect host port))
      (set sock string (call tcp_connect host port)))
    
    (set req string (call build_request "POST" host path body))
    (call tcp_send sock req)
    
    (set raw string (call tcp_receive sock 8192))
    (call tcp_close sock)
    
    (ret (call parse_response raw)))
  
  (fn get_status_text code int -> string
    (set code_str string (call string_from_int code))
    (set result string code_str)
    
    (if (call eq code 200)
      (set result string (call string_concat code_str " OK")))
    (if (call eq code 201)
      (set result string (call string_concat code_str " Created")))
    (if (call eq code 204)
      (set result string (call string_concat code_str " No Content")))
    (if (call eq code 400)
      (set result string (call string_concat code_str " Bad Request")))
    (if (call eq code 401)
      (set result string (call string_concat code_str " Unauthorized")))
    (if (call eq code 403)
      (set result string (call string_concat code_str " Forbidden")))
    (if (call eq code 404)
      (set result string (call string_concat code_str " Not Found")))
    (if (call eq code 500)
      (set result string (call string_concat code_str " Internal Server Error")))
    (if (call eq code 999)
      (set result string "Unknown Status"))
    
    (ret result))
  
  (meta-note "Pure AISL HTTP client using TCP/TLS primitives

Usage:
  (import http_pure)
  (set response map (call get \"https://example.com/api\"))
  (set body string (call map_get response \"body\"))
  (set status string (call map_get response \"status\"))

Functions:
  - parse_url(url) -> array [protocol host port path]
  - build_request(method host path body) -> string
  - parse_response(raw) -> map with keys: status body
  - get(url) -> map
  - post(url body) -> map

Dependencies:
  - tcp_connect / tcp_tls_connect (C primitives)
  - string_utils (stdlib)
  - conversion (stdlib)

Implementation notes:
  - Uses tcp_connect for http:// URLs
  - Uses tcp_tls_connect for https:// URLs
  - Builds HTTP/1.1 requests manually
  - Parses responses using string operations
  - No external dependencies - pure AISL!"))
