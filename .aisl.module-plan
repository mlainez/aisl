@(implementation-plan aisl-module-system)

@(goal
  "Minimize token consumption for LLM code generation while maximizing clarity.
   Extract stdlib into modules, simplify core to minimal primitives, reduce type explosion.")

@(principles
  (token-efficiency "Fewer operations in context = lower token cost")
  (explicit-imports "Imports clarify dependencies, enable selective loading")
  (type-simplification "One integer type, one float type - zero choice ambiguity")
  (namespace-clarity "Module prefixes document capability origin"))

@(phase-1 type-system-simplification
  @(rationale "4 numeric types (i32/i64/f32/f64) create choice ambiguity for LLMs.
              Simplify to int=i64, float=f64. Eliminates 50% of arithmetic opcodes.")
  
  @(changes
    (remove-types (i8 i16 i32 u8 u16 u32 u64 f32))
    (keep-types (i64 f64 bool string array map json result regex))
    (add-aliases (int -> i64) (float -> f64))
    (remove-opcodes
      OP_PUSH_I8 OP_PUSH_I16 OP_PUSH_I32 OP_PUSH_U8 OP_PUSH_U16 OP_PUSH_U32 OP_PUSH_U64 OP_PUSH_F32
      OP_ADD_I32 OP_SUB_I32 OP_MUL_I32 OP_DIV_I32 OP_MOD_I32 OP_NEG_I32
      OP_ADD_F32 OP_SUB_F32 OP_MUL_F32 OP_DIV_F32 OP_NEG_F32
      OP_EQ_I32 OP_NE_I32 OP_LT_I32 OP_GT_I32 OP_LE_I32 OP_GE_I32
      OP_EQ_F32 OP_NE_F32 OP_LT_F32 OP_GT_F32 OP_LE_F32 OP_GE_F32
      OP_MATH_ABS_I32 OP_MATH_ABS_F32 OP_MATH_MIN_I32 OP_MATH_MIN_F32
      OP_MATH_MAX_I32 OP_MATH_MAX_F32)
    (rename-opcodes
      (OP_PUSH_I64 -> OP_PUSH_INT)
      (OP_PUSH_F64 -> OP_PUSH_FLOAT)
      (OP_ADD_I64 -> OP_ADD_INT)
      (OP_ADD_F64 -> OP_ADD_FLOAT)
      (OP_EQ_I64 -> OP_EQ_INT)
      (OP_EQ_F64 -> OP_EQ_FLOAT)))
  
  @(impact
    (opcodes-removed 48)
    (llm-types-reduced "4 numeric types -> 2 numeric types")
    (token-savings "~25% reduction in type annotations")
    (user-syntax "(set x int 42)" vs "(set x i32 42)" - clearer intent)))

@(phase-2 core-stdlib-separation
  @(rationale "252 opcodes all in VM core. LLMs must know all functions.
              Split into minimal core + optional stdlib modules.
              Core = 30 opcodes. Stdlib = 170 opcodes across 12 modules.")
  
  @(core-operations 30
    @(stack 6 (push_int push_float push_string push_bool push_unit pop dup))
    @(locals 4 (load_local store_local load_global store_global))
    @(arithmetic 6 (add sub mul div mod neg))
    @(comparison 6 (eq ne lt gt le ge))
    @(logical 3 (and or not))
    @(control 4 (jump jump_if_false call return))
    @(cast 1 (cast)))
  
  @(stdlib-modules
    @(module string
      @(ops 15 (len concat split trim contains replace starts_with ends_with
                to_upper to_lower substring index_of from_int from_float)))
    
    @(module array
      @(ops 12 (new push pop get set len slice sort reverse filter map reduce join)))
    
    @(module map
      @(ops 8 (new get set has delete keys values len clear)))
    
    @(module json
      @(ops 10 (parse stringify new_object new_array get set has delete
                push length type)))
    
    @(module file
      @(ops 12 (read write append exists delete size mtime
                read_result write_result append_result
                list_dir create_dir delete_dir)))
    
    @(module http
      @(ops 10 (get post put delete patch request
                get_status get_body get_header set_header)))
    
    @(module net
      @(ops 8 (tcp_listen tcp_accept tcp_connect tcp_send tcp_recv tcp_close
               ws_connect ws_send ws_receive ws_close)))
    
    @(module regex
      @(ops 5 (compile match find find_all replace)))
    
    @(module crypto
      @(ops 6 (sha256 md5 hmac_sha256 base64_encode base64_decode)))
    
    @(module time
      @(ops 4 (now format parse sleep)))
    
    @(module sqlite
      @(ops 10 (open close exec query prepare bind step column reset finalize)))
    
    @(module io
      @(ops 5 (print println read_line write_file read_file))))
  
  @(syntax
    (import-statement "(import module-name)")
    (import-selective "(import (module-name fn1 fn2 fn3))")
    (import-alias "(import (module-name :as alias))")
    (qualified-call "(call module.function args)")
    (unqualified-call "(call function args)" ; if imported selectively)))

@(phase-3 module-implementation
  @(compiler-changes
    @(files
      (compiler/c/include/module.h "Module system types and registry")
      (compiler/c/src/module.c "Module loading and resolution")
      (compiler/c/src/stdlib/*.c "Extracted stdlib implementations"))
    
    @(steps
      (1 "Create module registry structure")
      (2 "Extract stdlib functions from runtime.c to modules")
      (3 "Implement import statement parsing")
      (4 "Add module resolution to function calls")
      (5 "Update bytecode to reference module+function")
      (6 "Modify VM to load modules lazily")))
  
  @(vm-changes
    @(lazy-loading "Only load module code when import statement executed")
    @(module-cache "Cache loaded modules per VM instance")
    @(namespace-table "Map qualified names to function addresses")))

@(phase-4 documentation-updates
  @(files
    (.aisl.grammar "Update with import syntax and simplified types")
    (.aisl.analysis "Document module system rationale")
    (AGENTS.md "Update examples to show imports and new types")
    (LANGUAGE_SPEC.md "Full module system specification"))
  
  @(grammar-changes
    (syntax "(prog (import*) (mod name fn*))")
    (types "int float bool string array map json result regex")
    (import "(import name) | (import (name :as alias)) | (import (name fn*))")))

@(phase-5 migration-strategy
  @(backward-compatibility
    (implicit-imports "If no imports, auto-import all core+stdlib - backward compat mode")
    (deprecation-path "Phase out i32/f32 over 3 releases with warnings")
    (test-migration "Update all 89 tests to use new types and imports"))
  
  @(migration-tool
    (script "scripts/migrate_to_modules.aisl")
    (function "Automatically add imports based on function usage")
    (function "Convert i32->int, f32->float in all test files")))

@(execution-order
  (1 phase-1 "Type system simplification - foundational change")
  (2 phase-4 "Update documentation - establish new conventions")
  (3 phase-2 "Design module system - API surface")
  (4 phase-3 "Implement modules - compiler and VM")
  (5 phase-5 "Migration - update tests and examples"))

@(success-metrics
  (token-reduction "50-70% fewer operations in .aisl.grammar @(op) section")
  (context-efficiency "LLM loads 30 core ops + only needed modules")
  (type-clarity "Zero choice between int types")
  (tests-passing "All 89 tests pass with new system")
  (backward-compat "Existing code runs with auto-import mode"))

@(rollback-plan
  (if-blocked "Keep i32/i64/f32/f64 as aliases until phase-3 complete")
  (feature-flag "MODULE_SYSTEM=0 to disable, use old behavior")
  (test-both "Run test suite in both modes during transition"))
